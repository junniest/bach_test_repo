\section{\label{s:introduction}Ievads}

%Mūsdienīgas programmēšanas valodas ātri attīstās, lai paliktu konkurētspējīgi un lietojami. Tomēr valodas sintakses izmaiņu ieviešanas process bieži aizņem daudz laika un pūļu. Tas ir tāpēc, ka vairākumam valodu eksistē vairāki kompilatori un piemīt mazas pašmodificēšanas spējas. Ir saprotams, ka ievērojami izmaiņu gadījumā būs nepieciešama kompilatoru pārstrāde. Taču nelielu sintaktisku izmaiņu gadījumā vairāku kompilatoru adaptēšana ir pārāk darbietilpīgs uzdevums.
%
%Šīs darbs apskata iespēju iznest valodas sintakses izmaiņas uz valodas lietotāja līmeni, t.i. dot lietotājam iespēju modificēt valodas sintaksi rakstot programmas. Tas dos iespēju lietotājiem pašiem ieviest izmaiņas, kas ir nepieciešamas, lai paplašināt valodas iespējas.
%
%Šādu iespēju dod dinamisku gramatiku pieejas pielietošana. Dinamiskas jeb adaptīvas gramatiku princips ir ļaut pievienot un dzēst valodas gramatikas likumus ar speciālām konstrukcijām. Tomēr šāda pieeja ir ļoti grūti kontrolējama, jo patvaļīgu gramatikas pārveidojumu gadījumā var tikt izveidota gramatika, ko nevarēs apstrādāt. Dinamisko gramatiku pielietošana arī prasa ļoti specifisku parsētāju izveidošanas pieeju, kas nozīmē ļoti nopietnu parsētāju pārstrādi, jo parasti parsētāji neatbalsta gramatikas modificēšanu programmas apstrādes laikā.
%
%Dinamisko gramatiku principa lietošana \emph{as is} ļoti cieši piesaistītu to konkrētas valodas gramatikai.
%Savukārt plānotā sistēma tiek projektēta ar iedomu, ka to varēs lietot dažādu valodu paplašināšanai ar minimālām nepieciešamām izmaiņām kompilatoros.
%
%Aprakstāmā sistēma neļaus pa tiešo modificēt valodas gramatikas likumus, bet gan piedāvās iespēju veidot makro izteiksmes, kas ļaus paplašināt valodu konstrukciju kopu ar jau eksistējošo konstrukciju kombinācijām. Sistēma tiks izveidota ka parsētāja virsbūve, tātad nebūs nepieciešama kardināla parsētāja pārstrāde.
%
%Piedāvātā sistēma ir balstīta uz sakarīgu gramatikas modifikāciju iespēju ierobežojumu, kā arī uz tipu sistēmas, kas ļaus pārliecināties, ka ieviestās modifikācijas ir korektas. Tas tiks nodrošināts ar specifisku makro šablonu sintaksi. Sistēmas galvenā īpašība ir tas, ka pēc gramatikas transformācijas izpildes modificētais izejas kods būs atpazīstams ar sākotnējo valodas gramatiku.
%
%Šīs darbs ir fokusēts uz regulāro izteiksmju šablonu apstrādi un sakrišanu meklēšanu programmas tokenu virknēs. Tas tiek izstrādāts transformācijas sistēmas projekta ietvaros. Lai parādītu šādas apakšsistēmas iespējamību tika izstrādāts sakrišanu meklēšanas apakšsistēmas prototips. Prototipa izstrādes galvenais uzdevums ir atrast efektīvu veidu, ka apstrādāt makro prioritātes, ieejas un izejas no programmas tvērumiem un sakrišanas konstatēšanu.

Mūsdienu programmēšanas valodas ir spēcīgi rīki, kas var tikt pielietojami dažādu uzdevumu risināšanai. Abstrakti programmēšanas valodas var sadalīt divās grupās - universālas un domēn-specifiskas valodas. Universālas valodas ir pielietojamas visās sfērās, bet domēn-specifiskas gan tiek veidotas kādas konkrētas uzdevumu klases risināšanai. Kaut arī universālas valodas var tikt lietotas šīs uzdevumu klases risināšanai, tās ne vienmēr ir tikpat izteiksmīgas.

Taču parasti tieši universālas programmēšanas valodas tiek lietotas lai risinātu specifiskus uzdevumus, jo ne visiem uzdevumiem eksistē domēn-specifiskas valodas. Domēn-specifiskas valodas ir rīks, ko ir vērts izstrādāt veselai klasei specializētu uzdevumu. Bet to izveide ir liels darbs, ko nav vērts pildīt, lai atrisināt vienu konkrētu uzdevumu.

Gandrīz jebkādas universālas programmēšanas valodas virzošs spēks ir funkcijas un to kompozīcijas. Katra valoda iekļauj sevī kaut kādu bāzes funkcionalitāti, funkciju ietvaru, kuru kompozīcijas un virknes veido programmas. Taču specifisku uzdevumu gadījumā funkciju kompozīcijas nepietiekami apraksta izpildāmo darbību. Dažas darbības ir ērtāk un saprotamāk (tas var būt pieņemts ārpus programmēšanas, reālās dzīves situācijās) attēlot ar citu sintaktisku formu, nevis ar funkciju. Šādas darbības piemērs varētu būt faktoriāla pieraksts - \verb|n!|, kas ir vispārpieņemts apzīmējums.

Viena no šādām sintaktiskām formām ir operatori, tomēr operatoru skaits un pārslogošanas iespējas valodās ir diezgan ierobežotas. To pārslogošana, piemēram, C vidē, neļaus attēlot faktoriālu ar \verb|!| zīmi, jo pārslogojot saglabājas tā prefiksā forma. Tātad operatoru pārslogošana arī nedod brīvību veidot konstrukcijas, kas varētu paaugstināt valodas izteiksmību. Bet citu rīku, kas varētu to piedāvāt, arī nav, jo universālas programmēšanas valodas bieži iekļauj ļoti ierobežotas sintakses mainīšanas iespējas.

Uz doto brīdi vairākumam mūsdienīgo programmēšanas valodu eksistē standarti. Pateicoties šim faktam, ir iespējams izstrādāt dažādus kompilatorus vienai un tai pašai valodai. Bet sintakses izmaiņu ieviešanas gadījumā ir jāmaina standarts, tātad ir jākoriģē arī visi valodas kompilatori. Dažreiz šīs izmaiņas ir tik nopietnas, ka tiešām prasa ievērojamas parsētāja modifikācijas, lai tiktu atbalstītas, bet dažreiz tās ir tikai sintaktiskas, piem. sintaktiskā cukura\footnote{Sintaktiskais cukurs (\emph{syntactic sugar}) ir speciālas konstrukcijas, kas tiek pievienotas lai to padarītu saprotamāku un lasāmāku cilvēkam. Šīs konstrukcijas nemaina valodas funkcionalitāti, bet gan atvieglo tās lietošanu. Izplatīts sintaktiskā cukura piemērs ir C valodas konstrukcija \texttt{a[i]}, kas patiesībā ir \texttt{*(a + i)}.} ieviešana.

Gadījumos, kad ir nepieciešams paplašināt valodu tā, lai tā būtu piemērotāka konkrētam uzdevumam, sintakses izmaiņas var būt nebūtiskas. Tomēr vairākums valodu neļaus šādas izmaiņas ieviest bez valodas gramatikas, un, secīgi, valodas standarta modifikācijas.

Šīs darbs izpēta jautājumu, kā ir iespējams iznest valodas sintakses izmaiņas uz valodas lietotāja līmeni, t.i. dot lietotājam iespēju sapratnes robežās modificēt valodas sintaksi rakstot programmas. Tas arī apskata iespēju, kā var dot valodas lietotājam iespēju izteikt kādu tam nepieciešamu funkcionalitāti ar netriviālām sintaktiskām konstrukcijām, nevis ar funkcijām. Tā ļaus papildināt valodas sintaksi ar ierobežotas makro konstrukciju kopas palīdzību, kas tiek veidota tā, lai ieviestās valodas konstrukcijas joprojām būtu jēdzīgas sākotnējās gramatikas ietvaros.

Darbs piedāvā risinājuma koncepciju, kas ļaus LL(k) parsējamām valodām pievienot sintakses transformācijas sistēmu, kura ļaus paplašināt valodas iespējas un specificēt valodas konstrukcijas pielietošanas domēnam. Tā tiek projektēta tādā veidā, lai tās integrēšana ar kādu eksistējošu parsētāju pieprasītu pēc iespējas minimālas pūles. 

Projektētā sistēma sastāv no trim globālām komponentēm - šablonu sakrišanu meklēšanas apakšsistēma, pārrakstīšanas apakšsistēma un tipu apakšsistēma. Šablonu apakšsistēma atpazīst makro šablonu sastapšanas reizes programmas tekstā, pārrakstīšanas apakšsistēma transformē atpazītās virknes, bet tipu apakšsistēma kontrolē pārveidojumu korektību.

Šīs darbs ir fokusēts uz šablonu sakrišanu apakšsistēmas projektēšanas un koncepcijas izstrādes. Transformācijas sistēmas makro šablonu kopa ir paplašināta ar regulāro izteiksmju elementiem, kas ļaus tai būt ekspresīvākai konstrukciju meklēšana. Šī darba ietvaros tika izpētīta un sastādīta algoritmu kopa, kas varētu ļaut efektīvi apstrādāt makro un meklēt transformējamās virknes. Darba gaitā tika izstrādāts prototips, kas parāda specifiskās šablonu sistēmas iespējamību un izveido bāzi tālākai transformāciju sistēmas izstrādei.

%Bieži izmaiņas ir valodas lietotāju iniciētas, jo tikai aktīvi lietojot valodu var izprast, kā tai trūkst, lai tā tiešām kļūtu par ērtu un populāru izstrādes rīku. Piedāvāt savas izmaiņas var dažādos veidos - informējot valodas izstrādātāju par kādas iespējas trūkumu, piedāvājot ielāpus kompilatoram, u.t.t.. Bet jebkādai izmaiņai ir nepieciešams atbalsts un lietotāju kvorums, kas vēlās šo izmaiņu lietot. To ir diezgan grūti dabūt ar šādiem izmaiņu pieprasījumiem.

%Tomēr jebkādas, pat nebūtiskas, valodas sintakses izmaiņas parasti prasa kompilatora vai vairāku kompilatoru pārstrādi. Tas varētu būt vērts tad, kad izmaiņas ir nepieciešamas vairākumam valodas lietotāju, bet gadījumos, kad universālas valodas ir lietotas specifisku uzdevumu risināšanai, tas tā nav.

Šī dokumenta organizācija ir sekojoša. Nodaļa~\ref{s:motivation} apraksta šī darba izstrādes pamatojumu un apskata gadījumus, kurus nevar apstrādāt lietojot jau eksistējošos rīkus. Nodaļa~\ref{s:system} apraksta piedāvāto sistēmu, tās īpašības un darbības principus. Nodaļa~\ref{s:prototype} stāsta par transformācijas sistēmas šablonu apstrādes apakšsistēmas prototipu, par algoritmiem, kas tika lietoti tā izstrādē. Nodaļa~\ref{s:results} apraksta prototipa testēšanas stratēģijas un izstrādes rezultātus, bet nodaļa~\ref{s:conclusions} piedāvā darba secinājumus un projekta turpināšanas perspektīvas.