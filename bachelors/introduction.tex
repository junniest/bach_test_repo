\section*{Ievads}
\label{s:introduction}
\addcontentsline{toc}{section}{Ievads}

Mūsdienu programmēšanas valodas ir spēcīgi rīki, kas var tikt pielietoti dažādu uzdevumu risināšanai. Atkarībā no pielietojuma tās tiek klasificētas universālās un domēn-specifiskās: domēn-specifiskās valodas tiek pielietotas konkrētas uzdevumu klases risināšanai, toties universālas - visiem uzdevumu veidiem. Domēn-specifiskās valodas projektēšana un implementācija ir pietiekami laikietilpīgs darbs, lai to veiktu viena konkrēta uzdevuma risināšanai, līdz ar to šīs valodas projektēšanai ir nozīme tikai veselas specializētu uzdevumu klases gadījumā.

Katras universālas programmēšanas valodas pamata sintaktiskais spēks ir funkcijas un to kompozīcijas. Katrai valodai piemīt noteikta bāzes funkcionalitāte  – funkciju ietvars, kur funkciju kompozīcijas un virknes veido atbilstošās programmas. Taču ir iespējamas situācijas, kad funkciju kompozīcijas nepietiekami izteiksmīgi apraksta izpildāmo darbību; kā arī dažas darbības ir ērtāk un saprotamāk attēlot ar citu sintaktisku formu, nevis ar funkciju (piemēram, faktoriālus ar pierakstu \verb|n!|).

Viena no sintaktiskām formām, kas varētu paagustināt koda lasāmību, ir operatori. Tomēr bieži vien programmēšanas valodas stingri ierobežo pieejamo operatoru un to argumentu skaitu, to asociatīvās īpašības (kreisā vai labā asociativitāte) un novietojumu (prefiksa, infiksa, postfiksa)\footnote{Dažas valodas, piemēram, Prolog, ļauj ieviest un pārslogot operatorus un mainīt to asociativitāti un novietojumu, bet neļauj veidot vairāku (>2) argumentu operatorus. Toties ir jāņem vērā, ka Prolog ir eksotiska valoda, pie kuras sintakses ir nepieciešams pierast.\cite{PrologStandard}}. Neskatoties uz to, ka, piemēram, C++ valoda ļauj pārslogot operatorus, tā nedod iespēju izveidot postfiksu konstrukciju \verb|n!| faktoriāla apzīmēšanai. Šāda uzvedība ir tipiska lielākai programmēšanas valodu  daļai. %Tātad operatoru pārslogošana arī nedod brīvību veidot konstrukcijas, kas varētu paaugstināt valodas izteiksmību. Bet citu rīku, kas varētu to piedāvāt, arī nav, jo universālas programmēšanas valodas bieži iekļauj ļoti ierobežotas sintakses mainīšanas iespējas.
l
Vienīga iespēja, kas šajā situācijā ļaus ieviest izmaiņas valodā, ir izmainīt valodas sintaksi. Uz doto brīdi lielākai mūsdienīgo valodu daļai eksistē standarti, kas ļauj izstrādāt dažādus kompilatorus vienai un tai pašai valodai. Sintakses izmaiņu ieviešanas gadījumā ir jāmaina standarts un tātad arī valodas kompilatori. Dažreiz šīs izmaiņas ir tik nopietnas, ka tiešām to atbalstīšanai ir nepieciešamas ievērojamas parsētāja modifikācijas, tomēr dažos gadījumos tās var būt tikai sintaktiskas, piem., sintaktiskā cukura\footnote{Sintaktiskais cukurs (\emph{syntactic sugar}) ir speciālas konstrukcijas, kas tiek pievienotas, lai padarītu valodu cilvēkam saprotamāku un lasāmāku. Šīs konstrukcijas nemaina valodas funkcionalitāti, bet gan atvieglo tās lietošanu. Izplatīts sintaktiskā cukura piemērs ir C valodas konstrukcija \texttt{a[i]}, kas patiesībā ir \texttt{*(a + i)}.} ieviešana.

Gadījumos, kad ir nepieciešams paplašināt valodu tā, lai tā būtu piemērotāka konkrētam uzdevumam, sintakses izmaiņas var nebūt būtiskas, tomēr lielāka valodu daļa arī šādas izmaiņas neļaus ievest bez valodas gramatikas un standarta modifikācijas. Tas ievērojami palēnina iespējas eksperimentēt ar valodas sintaksi.

Balstoties uz šiem novērojumiem, tiek izveidots šīs darbs, kas pēta, vai ir iespējams iznest valodas sintakses izmaiņas uz lietotāja līmeni, t.i. dot valodas lietotājam iespēju modificēt valodas sintaksi programmas rakstīšanas procesā, kā arī ļaut izteikt viņam nepieciešamo funkcionalitāti ar netriviālām sintaktiskām konstrukcijām, nevis izmantojot funkcijas. Darba mērķis ir atļaut lietotāja līmenī papildināt valodas sintaksi ar ierobežotas makro konstrukciju kopas palīdzību, kas ir veidota tā, lai ieviestās valodas konstrukcijas pēc transformēšanas joprojām būtu jēdzīgas sākotnējas gramatikas ietvaros.

Šīm mērķim tika izvēlēta pieeja, kas ir līdzīga koda priekšprocesēšanai. Programmas teksta priekšprocesēšanas gaitā nav iespējams precīzi paredzēt transformācijas rezultātu\footnote{Piemēram, gadījumos, kad priekšprocesēšanā tiek lietotas zarošanas konstrukcijas vai ir nepieciešama vairākkārtīga apstrāde, lai dabūtu beigu rezultātu.}. Darba mērķa sasniegšanai tiek piedāvāts makro šablonos lietot izejas koda daļiņas (angl. \emph{token}) un gramatikas produkcijas, kas dos iespēju kontrolēt katra šablona argumenta tipus. Šablonu transformācija tiks iznesta uz citu abstrakcijas līmeni un ļaus apstrādāt virknes ar daļējo izrēķināšanas iespēju.

Darbs piedāvā risinājuma koncepciju, kas ļaus LL(k) parsējamām valodām pievienot sintakses transformācijas sistēmu, kas paplašina valodas iespējas un specificē valodas konstrukcijas pielietošanas domēnam. Projektēta sistēma ir veidota tā, lai tās integrēšana ar kādu eksistējošu parsētāju pieprasītu pēc iespējas minimālas pūles. Sistēma sastāvēs no trim globālām komponentēm: šablonu sakrišanu meklēšana apakšsistēma, pārveidošanas apakšsistēma un tipu apakšsistēma. %Šablonu apakšsistēma atpazīst makro šablonu sastapšanas reizes programmas tekstā, pārveidošanas apakšsistēma transformē atpazītās virknes, bet tipu apakšsistēma kontrolē pārveidojumu korektumu iezīmēto tipu ietvaros.

Šīs darbs ir fokusēts uz šablonu sakrišanu apakšsistēmas projektēšanas un koncepcijas izstrādes. Transformācijas sistēmas makro šablonu kopa ir paplašināta ar regulāro izteiksmju elementiem, kas ļaus tai būt ekspresīvākai konstrukciju meklēšanā. Šī darba ietvaros tika izpētīta uzdevuma risināšanas iespējas un tika sastādīta algoritmu kopa, kas atļautu efektīvi apstrādāt makro un meklēt transformējamas virknes. Darba gaitā tika izstrādāts prototips, kas parāda specifiskās šablonu sistēmas iespējamību un izveido pamatu tālākai transformācijas sistēmas izstrādei. Prototipa izstrādes un testēšanas laikā tika identificēti šablonu sistēmas iespējamie ierobežojumi.

%Bieži izmaiņas ir valodas lietotāju iniciētas, jo tikai aktīvi lietojot valodu var izprast, kā tai trūkst, lai tā tiešām kļūtu par ērtu un populāru izstrādes rīku. Piedāvāt savas izmaiņas var dažādos veidos - informējot valodas izstrādātāju par kādas iespējas trūkumu, piedāvājot ielāpus kompilatoram, u.t.t.. Bet jebkādai izmaiņai ir nepieciešams atbalsts un lietotāju kvorums, kas vēlās šo izmaiņu lietot. To ir diezgan grūti dabūt ar šādiem izmaiņu pieprasījumiem.

%Tomēr jebkādas, pat nebūtiskas, valodas sintakses izmaiņas parasti prasa kompilatora vai vairāku kompilatoru pārstrādi. Tas varētu būt vērts tad, kad izmaiņas ir nepieciešamas vairākumam valodas lietotāju, bet gadījumos, kad universālas valodas ir lietotas specifisku uzdevumu risināšanai, tas tā nav.

Šī dokumenta organizācija ir sekojoša. Nodaļa~\ref{s:motivation} apraksta šī darba izstrādes pamatojumu un apskata gadījumus, kurus nevar apstrādāt, lietojot jau eksistējošos rīkus. Nodaļa~\ref{s:system} apraksta piedāvāto sistēmu, tās īpašības un darbības principus. Nodaļā~\ref{s:prototype} tiek apskatīts transformācijas sistēmas šablonu apstrādes apakšsistēmas prototips un darbā pielietotie algoritmi. Nodaļa~\ref{s:related} apskata dažus līdzīgus projektus un īsi atspoguļo to saturu. Tālāk tiek aprakstīti darba izstrādes rezultāti, secinājumi un projekta turpināšanas perspektīvas.