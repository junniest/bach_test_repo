\section*{\label{s:introduction}Ievads}
\addcontentsline{toc}{section}{Ievads}

Mūsdienu programmēšanas valodas ir spēcīgi rīki, kas var tikt pielietoti dažādu uzdevumu risināšanai. Abstrakti programmēšanas valodas var sadalīt divās grupās - universālas un domēn-specifiskas valodas. Universālas valodas ir pielietojamas visās sfērās, bet domēn-specifiskas gan tiek veidotas kādas konkrētas uzdevumu klases risināšanai. Kaut arī universālas valodas var tikt lietotas šīs uzdevumu klases risināšanai, tās ne vienmēr ir tikpat izteiksmīgas.

Taču parasti tieši universālas programmēšanas valodas tiek lietotas lai risinātu specifiskus uzdevumus, jo ne visiem uzdevumiem eksistē domēn-specifiskas valodas. Domēn-specifiskas valodas ir rīki ko ir vērts projektēt un veidot veselai klasei specializētu uzdevumu. Bet to implementācija ir liels darbs, ko nav vērts pildīt, lai atrisināt vienu konkrētu uzdevumu.

Jebkādas universālas programmēšanas valodas pamata sintaktiskais spēks ir funkcijas un to kompozīcijas. Katra valoda iekļauj sevī kaut kādu bāzes funkcionalitāti, funkciju ietvaru, kuru kompozīcijas un virknes veido programmas. Taču mēdz parādīties situācijas, kad funkciju kompozīcijas nepietiekami izteiksmīgi apraksta izpildāmo darbību. Dažas darbības ir ērtāk un saprotamāk attēlot ar citu sintaktisku formu, nevis ar funkciju (piemēram, faktoriāli ar pierakstu \verb|n!|).

Viena no sintaktiskām formām, kas varētu paaugstināt koda lasāmību ir operatori. Tomēr programmēšanas valodas bieži vien stingri ierobežo pieejamo operatoru skaitu, kā arī to argumentu skaitu, asociatīvo īpašību (kreisā vai labā asociativitāte) un novietojumu (prefiksa, infiksa, postfiksa)\footnote{Dažas valodas, piemēram, Prolog, ļauj ieviest un pārslogot operatorus un mainīt to asociativitāti un novietojumu, bet neļauj veidot trīs argumentu operatorus. Tomēr Prolog ir ļoti eksotiska valoda, pie kuras sintakses ir grūti pierast.\cite{PrologStandard}}. Kaut arī, piemēram, C++, ļauj pārslogot operatorus, valoda nedod iespēju izveidot postfiksu konstrukciju \verb|n!| faktoriāla apzīmēšanai. Šāda uzvedība ir tipiska vairākumam programmēšanas valodu. %Tātad operatoru pārslogošana arī nedod brīvību veidot konstrukcijas, kas varētu paaugstināt valodas izteiksmību. Bet citu rīku, kas varētu to piedāvāt, arī nav, jo universālas programmēšanas valodas bieži iekļauj ļoti ierobežotas sintakses mainīšanas iespējas.

Vienīgā iespēja, kas aprakstītajā situācijā ļaus ieviest izmaiņas valodā ir pamainīt pašu valodas sintaksi. Bet uz doto brīdi vairākumam mūsdienīgo programmēšanas valodu eksistē standarti. Pateicoties šim faktam, ir iespējams izstrādāt dažādus kompilatorus vienai un tai pašai valodai. Bet sintakses izmaiņu ieviešanas gadījumā ir jāmaina standarts, tātad ir jākoriģē arī visi valodas kompilatori. Dažreiz šīs izmaiņas ir tik nopietnas, ka tiešām prasa ievērojamas parsētāja modifikācijas, lai tiktu atbalstītas, bet dažreiz tās ir tikai sintaktiskas, piem. sintaktiskā cukura\footnote{Sintaktiskais cukurs (\emph{syntactic sugar}) ir speciālas konstrukcijas, kas tiek pievienotas lai to padarītu saprotamāku un lasāmāku cilvēkam. Šīs konstrukcijas nemaina valodas funkcionalitāti, bet gan atvieglo tās lietošanu. Izplatīts sintaktiskā cukura piemērs ir C valodas konstrukcija \texttt{a[i]}, kas patiesībā ir \texttt{*(a + i)}.} ieviešana.

Gadījumos, kad ir nepieciešams paplašināt valodu tā, lai tā būtu piemērotāka konkrētam uzdevumam, sintakses izmaiņas var būt nebūtiskas. Tomēr vairākums valodu neļaus šādas izmaiņas ieviest bez valodas gramatikas, un, secīgi, valodas standarta modifikācijas. Tas ievērojami palēnina iespējas eksperimentēt ar valodas sintaksi.

Uz šīm novērojumiem tiek bāzēts šīs darbs, kas izpēta jautājumu, kā ir iespējams iznest valodas sintakses izmaiņas uz valodas lietotāja līmeni, t.i. dot lietotājam iespēju modificēt valodas sintaksi rakstot programmas. Tas arī apskata iespēju, kā var dot valodas lietotājam iespēju izteikt kādu tam nepieciešamu funkcionalitāti ar netriviālām sintaktiskām konstrukcijām, nevis ar funkcijām. Tā ļaus papildināt valodas sintaksi ar ierobežotas makro konstrukciju kopas palīdzību, kas tiek veidota tā, lai ieviestās valodas konstrukcijas pēc transformēšanas joprojām būtu jēdzīgas sākotnējās gramatikas ietvaros.

Šīm mērķim tika izvēlēta pieeja, kas ir līdzīga koda priekšprocesēšanai. Programmas teksta priekšprocesēšanas gaitā nav iespējams precīzi paredzēt transformāciju rezultātu\footnote{Piemēram, gadījumos, kad priekšprocesēšanā tiek lietotas zarošanas konstrukcijas vai ir nepieciešama vairākkārtīga apstrāde lai dabūtu beigu rezultātu.}. Piedāvātā pieeja izvirza iespēju makro šablonos lietot izejas koda daļiņas (angl. \emph{token}) un gramatikas produkcijas, lai kontrolēt katra šablona argumenta tipus. Šablonu transformācija tiks iznesta uz citu abstrakcijas līmeni, un ļaus apstrādāt virknes ar daļējo izrēķināšanas iespēju.

Darbs piedāvā risinājuma koncepciju, kas ļaus LL(k) parsējamām valodām pievienot sintakses transformācijas sistēmu, kura ļaus paplašināt valodas iespējas un specificēt valodas konstrukcijas pielietošanas domēnam. Tā tiek projektēta tādā veidā, lai tās integrēšana ar kādu eksistējošu parsētāju pieprasītu pēc iespējas minimālas pūles. Projektētā sistēma sastāvēs no trim globālām komponentēm - šablonu sakrišanu meklēšanas apakšsistēma, pārveidošanas apakšsistēma un tipu apakšsistēma. %Šablonu apakšsistēma atpazīst makro šablonu sastapšanas reizes programmas tekstā, pārveidošanas apakšsistēma transformē atpazītās virknes, bet tipu apakšsistēma kontrolē pārveidojumu korektumu iezīmēto tipu ietvaros.

Šīs darbs ir fokusēts uz šablonu sakrišanu apakšsistēmas projektēšanas un koncepcijas izstrādes. Transformācijas sistēmas makro šablonu kopa ir paplašināta ar regulāro izteiksmju elementiem, kas ļaus tai būt ekspresīvākai konstrukciju meklēšana. Šī darba ietvaros autors izpētīja pieejamos risinājumus un uzdevuma risināšanas iespējas. Autors izvēlējās un sastādīja algoritmu kopu, kas varētu ļaut efektīvi apstrādāt makro un meklēt transformējamās virknes. Darba gaitā tika izstrādāts prototips, kas parāda specifiskās šablonu sistēmas iespējamību un izveido bāzi tālākai transformāciju sistēmas izstrādei. Prototipa izstrādes un testēšanas laika tika identificēti šablonu sistēmas iespējamie ierobežojumi. 

%Bieži izmaiņas ir valodas lietotāju iniciētas, jo tikai aktīvi lietojot valodu var izprast, kā tai trūkst, lai tā tiešām kļūtu par ērtu un populāru izstrādes rīku. Piedāvāt savas izmaiņas var dažādos veidos - informējot valodas izstrādātāju par kādas iespējas trūkumu, piedāvājot ielāpus kompilatoram, u.t.t.. Bet jebkādai izmaiņai ir nepieciešams atbalsts un lietotāju kvorums, kas vēlās šo izmaiņu lietot. To ir diezgan grūti dabūt ar šādiem izmaiņu pieprasījumiem.

%Tomēr jebkādas, pat nebūtiskas, valodas sintakses izmaiņas parasti prasa kompilatora vai vairāku kompilatoru pārstrādi. Tas varētu būt vērts tad, kad izmaiņas ir nepieciešamas vairākumam valodas lietotāju, bet gadījumos, kad universālas valodas ir lietotas specifisku uzdevumu risināšanai, tas tā nav.

Šī dokumenta organizācija ir sekojoša. Nodaļa~\ref{s:motivation} apraksta šī darba izstrādes pamatojumu un apskata gadījumus, kurus nevar apstrādāt lietojot jau eksistējošos rīkus. Nodaļa~\ref{s:system} apraksta piedāvāto sistēmu, tās īpašības un darbības principus. Nodaļa~\ref{s:related} apskata dažus līdzīgus projektus un īsi stāsta par to īpašībām. Nodaļa~\ref{s:prototype} stāsta par transformācijas sistēmas šablonu apstrādes apakšsistēmas prototipu, par algoritmiem, kas tika lietoti tā izstrādē. Tālāk tiek aprakstīti darba izstrādes rezultāti, secinājumus un projekta turpināšanas perspektīvas.