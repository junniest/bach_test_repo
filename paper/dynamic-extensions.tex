\section{\label{sec:dynext}Dynamic extension}

The preprocessing rules are defined using the following syntax:
\begin{verbatim}
match [\prod1] v = regexp   ->   [\prod2] f (v)
\end{verbatim}
This reads as following: if at the beginning of production \verb|prod1|
a stream of pseudo-tokens pointed by parser matches a regular expression
\verb|regexp|, which can be aliased with variable named \verb|v| in the
right hand side of the match, then the matched tokens will be replaced 
with a reduction of \verb|prod2| production applied on a list of 
pseudo-tokens that is being returned by \verb|f (v)|.  Function \verb|f|
is a function which is defined in functional language $T$ and which
is used to perform a preprocessing transformation on the list of 
tokens.  

The \verb|regexp| regular expression is a box standard regular
expression which is defined by the grammar at Fig.~\ref{reggram}.
\begin{figure}[h!]
\begin{verbatim}
regexp          ::= concat-regexp '|' regexp
concat-regexp   ::= asterisk-regexp  concat-regexp
asterisk-regexp ::= unary-regexp '*' | unary-regexp
unary-regexp    ::= pseudo-token | '(' regexp ')'
\end{verbatim}
\cation{\label{fig:reggram}Grammar of the regular expressions on
pseudo-tokens}
\end{figure}
In this paper we are using a minimalistic syntax for regular expression
to demonstrate some basic properties.  Later on, this syntax may be 
easily extended.

Further down in this paper we are going to use an escaped syntax 
for pseudo-tokens which represent grammar production names, like
\verb|\expr|, \verb|function|, etc.  The 
