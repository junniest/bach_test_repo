\section{Application}
\subsection{Syntax extension}
With the help of macro extension it is possible to extend language's syntax.
Assume, we would like to have a mathematical notation for absolute value, such
as \verb/|5|/, accessible. Then our macros will look like:
\begin{verbatim}
\match [\expr] v = \| \expr \| -> [\num] abs-match (tail (reverse (head
(reverse (v)))))

abs-match :: \expr -> \expr
abs-match x = abs(x)
\end{verbatim}
Here we define a new parser production to parse \verb|expr| rule. A matcher
will return a list with matched tokens, which will look like 
\verb/('|', ..., '|')/ From this list we need to remove the first and the last
tokens. For this purpose we use language constructs head, tail and reverse for
lists routine.  Then we substitute matched expression with a function call. In
this way, we can extend our basic language syntax.
\subsection{Templates}
The macroprocessor can be used as a metaprogramming techique similarly to
templates in C++. This will allow us to evaluate constant expressions in compile-time.
To illustrate this, let's consider factorial computation example.
\begin{verbatim}
\match [\number] v = \number ! -> [\number] fact-match (v)
\match [\expr] v = \expr ! -> [\expr] fact-match-expr (v)

match-fun fact-match :: \number -> \number
fact-match x = 1 if value (x) == 0
      | value (x) * fact-match (\number[value (x) - 1]) otherwise

match-fun fact-match-expr :: \expr -> \expr
fact-match-expr x = factorial (x)
\end{verbatim}
We provide here an extension of \verb|number| and \verb|expr| productions to
allow user to use a classical notation for factorial using exclamation sign In
case of occuring expression matched by \verb|expr| we simply call
\verb|factorial| function. Moreover, we want to compute expression in
compile-time if it is possible. In order to do this, we support match
specialisarion and nested match unrolling. Using \verb|value| interface we
evaluate an argument for recursive call. We have to make sure that resulting
type will be \verb|number|. Otherwise, the wrong match will be called.  This
example allows us to write \verb|3!| instead of an integer  number, and
compiler will return substituted and evaluated during compilation phase
expression \verb|6|.
\subsection{Preprocessing}
Using this approach macroprocessor doesn't allow us to parse some C
preprocessor's constructs. We provide the macroprocessor which handle parser's
context.  However, C preprocessor works out of scope. For example, we can use
\verb|#if ... #endif| directives wherever in the source code. However, our
macroprocessor works inside a context. This problem can be solved by
introducing macro language inside lexer. Although it allows to define arbitrary
macros out of any scope, we are to be careful with parser rules. If we define
an `out of scope' macro \verb|< ... >|, then binary operations occured in
parser \verb|<| and \verb|>| will be interpreted as parts of this directive.  
