
Как можно было бы обойтись вообще без регэкспов, итд?
Можно было бы разрешить пользователю дергать парсер за
get () и unget (), сравнивать результаты, и рекурсией сделать
любую звездочку.  Что тут плохого?  А хрен его знает -- может
и ничего, разве что эти парсерные функции получаются не чистые
ибо они дергают за состояние парсера, а матчи вполне себе чистые
в функциональном смысле.

def :foo () {
    :t = :get ()
    :t == \expr
        ? :return :cons (:t, :foo ())
        : :unget (), :return :nil;
}

Однако если верхнее разрешено, то никаких регэкспов не нужно -- 
нужно лишь порядок вызовов этой самой foo.

Тогда матч можно изобразить как-то так:

match [\expr]  :a = [:foo ()] -> [\expr] xx (a)

Откуда берутся злоебучие двоеточия?  Нужно придумаь какую-то
синтаксическую штуку, чтобы отличать переменные, функции и 
операторы внутри матчей от реальных токенов.  Может у кого-то
будет идея как это сделать получше.


Теперь примеры с матчами и возможные вопросы.


Типа хотим чтобы выражение |x| понималось как норма или модуль
от икса.  Пишем такой вот мачт:

# Unusual syntax support.
match [\expr] \| \expr \|
              -> [\expr] absolute ( \expr{1} )

| a |           -- correct
| a | b |       -- error
| ( a | b ) |   -- correct

Теперь сразу же вопрос -- а чего делать с приоритетами операций?
Можем ли мы разрулить случай |x|y|?  Вернее дать пользователю шанс
разруливать это?


Еще один стандартный пример -- матчи наследуются, так как когда
матч отрабатывае мы получаем грубо говоря набор токенов, который
парсер как бы снова хавает.  КСТАТИ хороший вопрос об оптимизации,
а именно -- можем ли пометить выражения слева так, чтобы парсер 
их повторно не парсил?  Если бы можно было так сделать -- это было
бы просто зашибись как охренительно.

# New operators, nested match expressions
match [\bin-expr] \primary ^ \primary   
                  ->  [\primary] xor ( \primary{1}, \primary{2} )
match [\assign-expr] \id ^= \expr ;
                  ->  [\assign] \id{1} = \id ^ \expr{1} ;



Теперь переходим к интересному:  мы можем описывать функции матча
сколько угодно, но есть как минимум три функции которые нам описать
не удастся -- это value (x), type (x) и eval (x).  То есть это 
фактически интерфейс к AST, которые возвращает каждая продукция.
Оно нам нжуно чтобы можно было чего-то вычислить, вопрос лишь в том
как нам определить тип этой штуки.  Хотелось бы чтобы value было
полиморфным, но может это нам не удастся, тогда будет intvalue, 
strvalue, ...

Это хорошо бы обсудить.


Тут я выполняю матч, если имя переменной соответствует такому-то 
регэкспу.  Что смешно, этот регэксп не имеет ничего общего с
печкиным регэкспом, тот что тут обыкновенный на строках.

# String regular expressions
match [\expr] \id[:value (\id{1}) ~= /foo.*\_x/] ( \expr )
              ->  [\expr] bar ( \expr{1} )


Глядя на эту штуку хочется спросить себя что разрешено внутри этих
фигурных скобок условий?  И кто это будет тайпчекать...


Далее жесть!


Напишем штуку на матчах которая заменяет список выражений через
запятую на список выражений через +.  То есть a,b,c -> a+b+c.

# Real regular expressions
match [\expr] :unwrap ( \binop ,  ,\? \expr )
              -> [\expr] \expr{1}
match [\expr] :unwrap ( \binop ,  ,\? \expr :q=[( , \expr \) *] )
              -> [\expr] \expr{1} \binop{1} :unwrap (\binop{1} , :q )
match [\expr] \id ( \expr \( , \expr \) * )            
              -> [\expr]  :unwrap ( + , \expr{1} \expr{*} )

Все ли тут хорошо с рекурсией?



Ну и пример, которым я уже делился -- заменяем все выражения вида
a * const  или  const * a  на  a + a + ... + a.

# Evaluation
match [\expr] \num * \expr[type (\expr{1}) != \num]
              |
              \expr[type (\expr{1}) != \num] * \num
              -> [\expr] __mult_num__ (\num{1} , \expr{1} )
match [\expr] __mult_num__ (\num :[value (\num{1} == 0)] , \expr)
              -> [\expr] \expr{1}
match [\expr] __mult_num__ (\num , \expr )
              -> [\expr] (__mult_num__ (:eval (:value (\num{1}) - 1))
                          + \expr{1})


Так, теперь вопрос главным образом к Печке -- как много матчей запихнуть
(желательно в один) автомат, чтобы можно было добавлять и выкидывать 
матчи на ходу.



