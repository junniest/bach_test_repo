\section{\label{sec:intro}Introduction}

Very often expressiveness of programming language introduce a number
ambiguities in its syntax.  The language specification clearly states
how to resolve the conflict, however it may not be possible to 
formulate the resolution in terms of context free grammars.  In order
to illustrate that consider the following examples.

\begin{enumerate}
    \item The classical example from C language is a type-cast 
          syntax.  As a user can define an arbitrary type using
          \verb|typedef| construct, the type casting expression
          \verb|(x) + 5| is undecidable, unless we know if
          \verb|x| is a type or not.
    \item Assume that we extend C syntax to allow an array 
          concatenation using infix binary \verb|++| operator and
          constant-arrays to be written as \verb|[1, 2, 3]|.
          We immediately run into the problem to disambiguate the 
          following expression: \verb|a ++ [1]|, as it could mean
          an application of postfix \verb|++| indexed by \verb|1|
          or it could be an array concatenation of \verb|a| and 
          \verb|[1]|.
    \item Assuming the language allows any unary function or operator
          to be applied as infix and postfix, we cannot 
          disambiguate the following expression:
\begin{verbatim}
log (x) - log (y)
\end{verbatim}
          Potential interpretations are: 
          \verb|log (uminus (log (x))) (y)|, which is obviously an 
          error, or \verb|minus (log (x), log (y))|.
\end{enumerate}

\noindent
Sometimes the context may influences not only parsing decisions but 
also lexing decisions.  Consider the following examples:
\begin{enumerate}
    \item C++ allows nested templates, which means that one could
          write an expression \verb|template <typename foo, list <int>>|, 
          assuming that the last \verb|>>| is two closing groups.  In
          order to do that, the lexer must be aware of this context,
          as in a standard context character sequence \verb|>>| means
          shift right operation.
    \item Assuming that a programmer is allowed to define her own 
          operators, the lexer rules must be changed, in case 
          the name of a new operator extends the existing one.  For
          example, assume one defines an operation \verb|+-|.
          It means that from now on an expression \verb|+-5| should
          be lexed as (\verb|+-|, \verb|5|), rather than (
          \verb|+|, \verb|-|, \verb|5|).
\end{enumerate}

In order to resolve the above ambiguities using LALR parser generator
engine, we have to make sure that one can annotate the grammar with a
correct choices for each shift/reduce or reduce/reduce conflict, which
puts a number of requirements on the syntax of parser generator and on
the finite-state machine execution engine.  Secondly, we have to
introduce contexts without interfering with the above
conflict-resolution.  Finally, one has to have an interface to a lexer
in case lexing is context-dependent, and all the mechanisms should be
aware of error-recovery facilities.

Having said that, we may see that using parser generators could be of
the same challenge as writing a parser by hands, where all the
ambiguities could be carefully resolved according to the language
specification.  As it turns out, most of the complicated languages
front-ends use hand-written recursive descendent parsers, specially
treating ambiguous cases.  For example the following languages do:
C/C++/ObjectiveC in GNU GCC~\cite{gcc}, clang in LLVM~\cite{clang}, 
JavaScript in Google V8~\cite{v8}.

